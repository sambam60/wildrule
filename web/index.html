<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wildrule</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <style>
      :root { color-scheme: dark; }
      html, body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        padding: 0;
        background: #11131a;
        overflow: hidden;
      }
      #terminal {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="terminal"></div>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <!-- Config: Set WS_SERVER_URL to your deployed backend URL (e.g., "your-app.onrender.com") -->
    <script>window.WS_SERVER_URL = "wildrule.onrender.com";</script>
    <script>
      let term;
      let ws;
      
      function startTerminal() {
        const container = document.getElementById('terminal');
        // Guard: wait for libs
        if (!(window.Terminal && window.FitAddon && window.FitAddon.FitAddon)) {
          setTimeout(startTerminal, 50);
          return;
        }
        term = new window.Terminal({
          cursorBlink: true,
          fontFamily: 'Menlo, Monaco, Consolas, "Courier New", monospace',
          fontSize: 14,
          theme: { background: '#0b0d14', foreground: '#dcdcdc', cursor: '#58a6ff' }
        });
        const fitAddon = new window.FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(container);
        const doFit = () => { try { fitAddon.fit(); } catch (_) {} };
        window.addEventListener('resize', doFit);
        doFit();

        // WebSocket wiring
        function append(text) { term.write(text); }
        
        // Get server URL from window.WS_SERVER_URL or use location.host
        const serverHost = window.WS_SERVER_URL || location.host;
        const proto = location.protocol === 'https:' ? 'https' : 'http';
        const serverUrl = `${proto}://${serverHost}`;
        
        // Health check to wake up instance
        let dots = 0;
        const statusInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          const dotsStr = '.'.repeat(dots);
          term.write(`\r\x1b[K[${
            new Date().toLocaleTimeString()
          }] Waking up instance${dotsStr}    `);
        }, 500);
        
        let attempts = 0;
        const maxAttempts = 100; // ~50 seconds with 500ms intervals
        
        function checkHealth() {
          attempts++;
          
          fetch(`${serverUrl}/health`)
            .then(response => {
              if (response.ok) {
                clearInterval(statusInterval);
                append('\r\n\x1b[K✓ Server is awake! Connecting...\r\n');
                connectWebSocket();
              } else {
                throw new Error('Health check failed');
              }
            })
            .catch(error => {
              if (attempts >= maxAttempts) {
                clearInterval(statusInterval);
                append('\r\n\x1b[K✗ Failed to wake up server after multiple attempts.\r\n');
                append('Please refresh the page and try again.\r\n');
              } else {
                setTimeout(checkHealth, 500);
              }
            });
        }
        
        function connectWebSocket() {
          // Get WebSocket URL
          const wsHost = window.WS_SERVER_URL || location.host;
          const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
          const wsUrl = wsHost.startsWith('ws://') || wsHost.startsWith('wss://') 
            ? `${wsHost}/ws` 
            : `${wsProto}://${wsHost}/ws`;
          
          console.log('Connecting to:', wsUrl);
          
          ws = new WebSocket(wsUrl);
          ws.addEventListener('open', () => {
            append('Connected to server...\r\n');
            setTimeout(() => { ws.send('n\n'); setTimeout(() => ws.send('n\n'), 120); }, 250);
          });
          ws.addEventListener('message', (e) => append(e.data));
          ws.addEventListener('close', () => append('\r\n[Connection closed]\r\n'));
          ws.addEventListener('error', (e) => {
            console.error('WebSocket error:', e);
            append('\r\n[Connection error - check console]\r\n');
          });
        }
        
        // Start health check
        setTimeout(checkHealth, 100);
        
        // Simple line editor: buffer until Enter, support Backspace
        let buf = '';
        term.onData(d => {
          if (d === '\r' || d === '\n') {
            term.write('\r\n');
            if (ws && ws.readyState === WebSocket.OPEN) ws.send(buf + '\n');
            buf = '';
            return;
          }
          // Backspace / DEL
          if (d === '\u0008' || d === '\x7f') {
            if (buf.length > 0) {
              buf = buf.slice(0, -1);
              term.write('\b \b');
            }
            return;
          }
          // Ignore other control chars
          if (d < ' ') return;
          buf += d;
          term.write(d);
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startTerminal);
      } else {
        startTerminal();
      }
    </script>
  </body>
</html>

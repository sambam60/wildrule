<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Wildrule</title>
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/xterm@5.3.0/css/xterm.min.css" />
    <style>
      :root { color-scheme: dark; }
      html, body {
        height: 100vh;
        width: 100vw;
        margin: 0;
        padding: 0;
        background: #11131a;
        overflow: hidden;
      }
      #terminal {
        width: 100%;
        height: 100%;
      }
    </style>
  </head>
  <body>
    <div id="terminal"></div>
    <script src="https://cdn.jsdelivr.net/npm/xterm@5.3.0/lib/xterm.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/xterm-addon-fit@0.8.0/lib/xterm-addon-fit.min.js"></script>
    <!-- Config: Set WS_SERVER_URL to your deployed backend URL (e.g., "your-app.onrender.com") -->
    <script>window.WS_SERVER_URL = "wildrule.onrender.com";</script>
    <script>
      let term;
      let ws;
      
      function startTerminal() {
        const container = document.getElementById('terminal');
        // Guard: wait for libs
        if (!(window.Terminal && window.FitAddon && window.FitAddon.FitAddon)) {
          setTimeout(startTerminal, 50);
          return;
        }
        term = new window.Terminal({
          cursorBlink: true,
          fontFamily: 'Menlo, Monaco, Consolas, "Courier New", monospace',
          fontSize: 14,
          theme: { background: '#0b0d14', foreground: '#dcdcdc', cursor: '#58a6ff' }
        });
        const fitAddon = new window.FitAddon.FitAddon();
        term.loadAddon(fitAddon);
        term.open(container);
        const doFit = () => { try { fitAddon.fit(); } catch (_) {} };
        window.addEventListener('resize', doFit);
        doFit();

        // WebSocket wiring
        function append(text) { term.write(text); }
        
        // WebSocket connection with retry logic to wake up instance
        let dots = 0;
        const statusInterval = setInterval(() => {
          dots = (dots + 1) % 4;
          const dotsStr = '.'.repeat(dots);
          term.write(`\r\x1b[K[${
            new Date().toLocaleTimeString()
          }] Waking up instance${dotsStr}    `);
        }, 500);
        
        let attempts = 0;
        const maxAttempts = 120; // ~60 seconds with 500ms intervals
        
        function tryConnect() {
          attempts++;
          
          // Get WebSocket URL
          const wsHost = window.WS_SERVER_URL || location.host;
          const wsProto = location.protocol === 'https:' ? 'wss' : 'ws';
          const wsUrl = wsHost.startsWith('ws://') || wsHost.startsWith('wss://') 
            ? `${wsHost}/ws` 
            : `${wsProto}://${wsHost}/ws`;
          
          console.log(`Attempt ${attempts}: Connecting to ${wsUrl}...`);
          
          try {
            const testWs = new WebSocket(wsUrl);
            
            const timeout = setTimeout(() => {
              testWs.close();
              if (attempts >= maxAttempts) {
                clearInterval(statusInterval);
                append('\r\n\x1b[K✗ Failed to wake up server after multiple attempts.\r\n');
                append('Please refresh the page and try again.\r\n');
              } else {
                setTimeout(tryConnect, 500);
              }
            }, 2000);
            
            testWs.addEventListener('open', () => {
              clearTimeout(timeout);
              clearInterval(statusInterval);
              append('\r\n\x1b[K✓ Server is awake! Connected.\r\n');
              
              // Now use the working connection
              ws = testWs;
              ws.addEventListener('message', (e) => append(e.data));
              ws.addEventListener('close', () => append('\r\n[Connection closed]\r\n'));
              ws.addEventListener('error', (e) => {
                console.error('WebSocket error:', e);
                append('\r\n[Connection error - check console]\r\n');
              });
              
              setTimeout(() => { ws.send('n\n'); setTimeout(() => ws.send('n\n'), 120); }, 250);
            });
            
            testWs.addEventListener('error', () => {
              clearTimeout(timeout);
              if (attempts >= maxAttempts) {
                clearInterval(statusInterval);
                append('\r\n\x1b[K✗ Failed to wake up server after multiple attempts.\r\n');
                append('Please refresh the page and try again.\r\n');
              } else {
                setTimeout(tryConnect, 500);
              }
            });
            
            testWs.addEventListener('close', () => {
              clearTimeout(timeout);
            });
            
          } catch (error) {
            console.error('Error creating WebSocket:', error);
            if (attempts >= maxAttempts) {
              clearInterval(statusInterval);
              append('\r\n\x1b[K✗ Failed to wake up server after multiple attempts.\r\n');
              append('Please refresh the page and try again.\r\n');
            } else {
              setTimeout(tryConnect, 500);
            }
          }
        }
        
        // Start connection attempts
        setTimeout(tryConnect, 100);
        
        // Simple line editor: buffer until Enter, support Backspace
        let buf = '';
        term.onData(d => {
          if (d === '\r' || d === '\n') {
            term.write('\r\n');
            if (ws && ws.readyState === WebSocket.OPEN) ws.send(buf + '\n');
            buf = '';
            return;
          }
          // Backspace / DEL
          if (d === '\u0008' || d === '\x7f') {
            if (buf.length > 0) {
              buf = buf.slice(0, -1);
              term.write('\b \b');
            }
            return;
          }
          // Ignore other control chars
          if (d < ' ') return;
          buf += d;
          term.write(d);
        });
      }

      if (document.readyState === 'loading') {
        document.addEventListener('DOMContentLoaded', startTerminal);
      } else {
        startTerminal();
      }
    </script>
  </body>
</html>
